---
title: "Coding Assignment: ECDFs, Q–Q Plots, and Many Distributions"
subtitle: "A quick recap + starter patterns you will extend"
author: "Jared Edgerton"
output:
  xaringan::moon_reader:
    css: [default, metropolis, metropolis-fonts, plsc498.css]
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: ""
---

# Today (quick recap → code you will extend)

We are practicing *distribution-first* diagnostics and comparisons:

- ECDFs (including tail-focused / descending ECDFs)
- Q–Q plots (normality checks; group A vs group B)
- Many-group comparisons (box/violin + raw points)
- Small multiples (facets) for scale-consistent comparison

Goal: write code patterns you can reuse directly with **GSS-style** variables:
- income
- education
- party ID
- attitude items (Likert-style)

---

# Setup

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(ggplot2)

set.seed(123)
```

---

# Simulated data 

Design goals for this synthetic dataset: (a) **income** is right-skewed, (b) **party** groups differ slightly, (c) **education** is discrete-ish (years / buckets), and (d) **attitude** is bounded (Likert-like)

```{r, message=FALSE, warning=FALSE}
n <- 2500
party <- sample(c("Dem", "Ind", "Rep"), size = n, replace = TRUE, prob = c(0.35, 0.30, 0.35))
party <- factor(party, levels = c("Dem", "Ind", "Rep"))
educ_years <- sample(8:20, size = n, replace = TRUE, prob = c(rep(1, 4), rep(2, 4), rep(3, 5))/27)
educ_cat <- case_when(educ_years <= 11 ~ "HS or less", educ_years %in% 12:15 ~ "Some college", educ_years >= 16 ~ "College+")
educ_cat <- factor(educ_cat, levels = c("HS or less", "Some college", "College+"))
party_shift <- ifelse(party == "Dem", 0.00, ifelse(party == "Ind", 0.05, 0.10))
educ_shift  <- (educ_years - 12) * 0.06
income <- rlnorm(n, meanlog = 10.2 + party_shift + educ_shift, sdlog = 0.55)
attitude_cont <- rnorm(n, mean = 4.2 + ifelse(party == "Dem", 0.2, ifelse(party == "Ind", 0.0, -0.2)), sd = 1.2)
attitude <- pmin(pmax(attitude_cont, 1), 7)
attitude <- round(attitude)
df <- tibble(
  party = party,
  educ_years = educ_years,
  educ_cat = educ_cat,
  income = income,
  attitude = attitude
)
```

---

# Quick visual check: skew + bounds

```{r, message=FALSE, warning=FALSE, fig.width=7, fig.height=3.8}
ggplot(df, aes(x = income)) +
  geom_histogram(binwidth = 25000) +
  theme_classic()
```

---

# Starter pattern: ECDF 

ECDF = “fraction of observations ≤ x” (no binwidth; no bandwidth).

```{r, message=FALSE, warning=FALSE, fig.width=7, fig.height=4}
ggplot(df, aes(x = income)) +
  stat_ecdf(geom = "step") +
  theme_classic()
```

---

# Starter pattern: ECDF by subgroup 

Overlay works best with a small number of groups.

```{r, message=FALSE, warning=FALSE, fig.width=7, fig.height=4}
ggplot(df, aes(x = income, color = party)) +
  stat_ecdf(geom = "step") +
  theme_classic()
```

Interpretation prompts you should be able to answer:
- At any income threshold, which group has the larger share below it?
- Where do the ECDF curves diverge most?

---

# Tail emphasis: descending ECDF

Descending ECDF is useful when the right tail is the story (large values).

```{r, message=FALSE, warning=FALSE, fig.width=7, fig.height=4}
ggplot(df, aes(x = income, color = party)) +
  stat_ecdf(aes(y = after_stat(1 - y)), geom = "step") +
  theme_classic() +
  labs(y = "Fraction ≥ x (descending ECDF)")
```

---

# Tail emphasis: log axis 

If the right tail compresses everything, try a log scale.

```{r, message=FALSE, warning=FALSE, fig.width=7, fig.height=4}
ggplot(df, aes(x = income, color = party)) +
  stat_ecdf(geom = "step") +
  scale_x_log10() +
  theme_classic() +
  labs(x = "income (log10 scale)")
```

---

# Tail emphasis: label with scales


```{r, message=FALSE, warning=FALSE, fig.width=7, fig.height=4}
library(scales)
ggplot(df, aes(x = income, color = party)) +
  stat_ecdf(geom = "step") +
  scale_x_log10(
    breaks = trans_breaks("log10", function(x) 10^x),
    labels = trans_format("log10", math_format(10^.x))
  ) +
  theme_classic() +
  labs(x = "income (log10 scale)", y = "ECDF")
```

---

# Starter pattern: Q–Q plot

This asks: “If income were normal, would the quantiles line up?”

```{r, message=FALSE, warning=FALSE, fig.width=7, fig.height=4}
ggplot(df, aes(sample = income)) +
  stat_qq() +
  stat_qq_line() +
  theme_classic()
```

---

# Q–Q plot with a transform 

Right-skew + heavy tails often look “more normal” after logging.

```{r, message=FALSE, warning=FALSE, fig.width=7, fig.height=4}
df <- df %>%
  mutate(income_log = log10(income))
ggplot(df, aes(sample = income_log)) +
  stat_qq() +
  stat_qq_line() +
  theme_classic() +
  labs(title = "Q–Q on log10(income)")
```

---

# Q–Q by subgroup

Use facets when overlay becomes cluttered.

```{r, message=FALSE, warning=FALSE, fig.width=6, fig.height=3.0}
ggplot(df, aes(sample = income_log)) +
  stat_qq(size = 0.8, alpha = 0.6) +
  stat_qq_line() +
  facet_wrap(~ party) +
  theme_classic()
```

Interpretation prompts:
- Do tails differ across groups?
- Does any group depart more strongly from the line?

---

# Group A vs Group B quantiles


```{r, message=FALSE, warning=FALSE, fig.width=5.1, fig.height=3.0}
probs <- seq(0.01, 0.99, by = 0.01)
q_dem <- quantile(df$income_log[df$party == "Dem"], probs = probs, na.rm = TRUE)
q_rep <- quantile(df$income_log[df$party == "Rep"], probs = probs, na.rm = TRUE)
qq_groups <- tibble(q_dem = as.numeric(q_dem), q_rep = as.numeric(q_rep))
ggplot(qq_groups, aes(x = q_dem, y = q_rep)) +
  geom_point(alpha = 0.8, size = 1.5) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  theme_classic() +
  labs(x = "Dem quantiles (log10 income)", y = "Rep quantiles (log10 income)")
```

Reading:
- Points above the line mean Rep quantiles are larger at that percentile.
- Curvature near ends indicates tail differences.

---

# Many groups: boxplot + points

Default: start with a compact summary, then show individuals.

```{r, message=FALSE, warning=FALSE, fig.width=7, fig.height=4}
ggplot(df, aes(x = party, y = income_log)) +
  geom_boxplot(outlier.shape = NA) +
  geom_point(position = position_jitter(width = 0.15), alpha = 0.20, size = 0.8) +
  theme_classic() +
  labs(y = "log10(income)")
```

---

# Many groups: violin + points (attitudes)

Violin = density shape; points = the raw observations.

```{r, message=FALSE, warning=FALSE, fig.width=7, fig.height=4}
ggplot(df, aes(x = party, y = attitude)) +
  geom_violin(trim = TRUE) +
  geom_point(position = position_jitter(width = 0.15), alpha = 0.25, size = 0.8) +
  theme_classic()
```

---

# Small multiples: education × party

This is a “multipanel” move: same plot, repeated for comparison.

```{r, message=FALSE, warning=FALSE, fig.width=8, fig.height=5}
ggplot(df, aes(x = income_log, color = party)) +
  stat_ecdf(geom = "step") +
  facet_wrap(~ educ_cat) +
  theme_classic() +
  labs(x = "log10(income)")
```

