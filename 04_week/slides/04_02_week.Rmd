---
title: "Coding Assignment: Color Encodings"
subtitle: "Sequential color, party structure, and interpretation"
author: "Jared Edgerton"
output:
  xaringan::moon_reader:
    css: [default, metropolis, metropolis-fonts, plsc498.css]
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: ""
---


# What you should remember

This is a short recap and extension.

You should already be comfortable with:

- Mapping vs styling
- Sequential vs categorical encodings
- Log transforms and scale transforms
- Using color deliberately, not decoratively

Today we extend that to **political ideal-point plots**.

---

# Setup

```{r, message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)

set.seed(123)
```

---

# Simulated DW-NOMINATE-style data

We simulate four congresses and two ideological dimensions.

```{r}
n_per <- 350

df_nom <- expand.grid(
  congress = c(1990, 2000, 2010, 2020),
  id = 1:n_per
)

df_nom <- df_nom %>%
  mutate(
    party = sample(c("DEMOCRAT", "REPUBLICAN"), n(), replace = TRUE),
    dim1 = rnorm(n(), mean = ifelse(party == "DEMOCRAT", -0.5, 0.5), sd = 0.35),
    dim2 = rnorm(n(), sd = 0.3)
  ) %>% 
  filter(congress == 1990)
```

---

# Sanity check

```{r}
head(df_nom)
table(df_nom$party)
table(df_nom$congress)
```

---

# Baseline plot (no color logic yet)

```{r fig.width=5, fig.height=3}
ggplot(df_nom, aes(x = dim1, y = dim2)) +
  geom_point(alpha = 0.5) + 
  theme_classic()
```

Interpretation:
- Structure exists, but party separation is unclear
- All points are visually equal

---

# Mapping color to party (categorical)

```{r fig.width=5, fig.height=3}
ggplot(df_nom, aes(x = dim1, y = dim2, color = party)) +
  geom_point(alpha = 0.6)  + 
  theme_classic()
```

Interpretation:
- Party separation becomes visible
- This is **categorical color**

---

# Sequential color within party (intentional choice)

Now we use **sequential color** *within* each party to show density along dim1.

```{r fig.width=5, fig.height=2.25}
ggplot(df_nom, aes(x = dim1, y = dim2, color = dim1)) +
  geom_point(alpha = 0.6) +
  scale_color_gradient(low = "lightgray", high = "blue") +
  labs(color = "Ideology (Dim 1)") + 
  theme_classic()
```

Interpretation:
- Darker = more extreme on dimension 1
- Color now encodes magnitude, not category

---

# Why this works

- dim1 is ordered and continuous
- A sequential palette reinforces direction
- Lightness carries the ordering information

This would *not* make sense for party labels.

---

# Common mistake (do not copy)

```{r fig.width=5, fig.height=3}
ggplot(df_nom, aes(x = dim1, y = dim2, color = as.numeric(as.factor(party)))) +
  geom_point() +
  scale_color_gradient(low = "lightgray", high = "blue") + 
  theme_classic()
```

Interpretation:
- A gradient implies order that does not exist
- This is misleading

---

# Recap: what color is doing here

- Color can distinguish groups (**party**)
- Color can represent magnitude (**ideology score**)
- The palette choice must match the variable type

If those don’t align, the plot lies.

---

# Starter pattern for today’s coding

```{r, fig.width=5, fig.height=2.5}
ggplot(df_nom, aes(x = dim1, y = dim2, color = dim1)) +
  geom_point(alpha = 0.6) +
  scale_color_gradient(low = "lightgray", high = "blue") +
  labs(
    x = "DW-NOMINATE Dimension 1",
    y = "DW-NOMINATE Dimension 2",
    color = "Ideology"
  ) + 
  theme_classic()
```

---

# What you should be able to say out loud

- “This is a **sequential color scale** because the variable is ordered.”
- “Lightness encodes extremity.”
- “Using a gradient for party would be incorrect.”
- “Color is doing analytic work here.”

---

# Transition to coding session

You now have:

- simulated data with the right structure
- a correct baseline plot
- an example of a **correct** sequential color encoding

Extend this pattern in the coding session.
