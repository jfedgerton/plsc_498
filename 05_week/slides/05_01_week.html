<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Choosing Visualizations, Proportional Ink, and Tidy Data</title>
    <meta charset="utf-8" />
    <meta name="author" content="Jared Edgerton" />
    <script src="05_01_week_files/header-attrs-2.29/header-attrs.js"></script>
    <link href="05_01_week_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="05_01_week_files/remark-css-0.0.1/metropolis.css" rel="stylesheet" />
    <link href="05_01_week_files/remark-css-0.0.1/metropolis-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="plsc498.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Choosing Visualizations, Proportional Ink, and Tidy Data
]
.subtitle[
## Matching questions to plots and shaping data for ggplot
]
.author[
### Jared Edgerton
]

---


class: center, middle, inverse, title-slide

.title[
# Choosing Visualizations, Proportional Ink, and Tidy Data
]
.subtitle[
## Matching questions to plots and shaping data for ggplot
]
.author[
### Jared Edgerton
]

---

# Quiz on canvas

- Log on to the course website to take it.
- You have 10 minutes.
- It is open notes and web.
- Do not generate your answers with AI.

---

# Quick Recap

- Color has different jobs:
  - **distinguish categories**
  - **represent magnitude**
  - **highlight**
- Mapping vs styling:
  - **Mapping** = data → visual property (`aes(...)`)
  - **Styling** = fixed appearance
- Common pitfalls:
  - too many categories
  - rainbow palettes
  - color choices that hide the message
- Accessibility basics:
  - limit colors
  - use redundancy
  - label clearly

---

# Why this matters

A plot is a choice about:

- what question you are answering
- what comparisons you want the reader to make
- what you are willing to hide

**Core idea:**  
Choose the visualization based on the task, not on habit.

---

# Setup


``` r
library(ggplot2)
library(dplyr)
library(tidyr)

set.seed(123)
```

---

# Simulate several “plot-ready” datasets



``` r
df_amounts &lt;- data.frame(
  category = c("A", "B", "C", "D", "E"),
  value = c(18, 34, 12, 27, 41))
df_dist &lt;- data.frame(
  group = sample(c("Control", "Treatment"), 400, replace = TRUE),
  outcome = rnorm(400, mean = ifelse(sample(c("Control","Treatment"), 400, replace=TRUE)=="Treatment", 0.4, 0), sd = 1))
df_props &lt;- data.frame(
  segment = c("X", "Y", "Z"),
  count = c(30, 15, 5)) %&gt;%
  mutate(prop = count / sum(count))
df_xy &lt;- data.frame(
  x = runif(30, 0, 10)) %&gt;%
  mutate(y = 2 + 0.6 * x + rnorm(30, sd = 1.2))
df_time &lt;- data.frame(
  t = 1:50,
  y = 10 + 0.15 * 1:50 + rnorm(length(50), sd = 1.0))
df_unc &lt;- data.frame(
  label = c("A","B","C","D","E"),
  est = c(0.2, 0.5, 0.35, 0.6, 0.4),
  lo = c(0.1, 0.35, 0.2, 0.45, 0.25),
  hi = c(0.3, 0.65, 0.5, 0.75, 0.55))
```

---

# A quick “directory” of visualization tasks

Most plots you will make fall into one of these tasks:

- **Amounts**: how much? (category → value)
- **Distributions**: how are values spread?
- **Proportions**: parts of a whole
- **Relationships**: how does y change with x?
- **Time**: change across time
- **Uncertainty**: how precise is an estimate?

---

# Amounts: bar chart (baseline)

Use when:
- you want to compare magnitudes across categories


``` r
ggplot(df_amounts, aes(x = category, y = value)) +
  geom_col() + 
  theme_classic()
```

![](05_01_week_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

---

# Amounts: dot plot (often cleaner)

A dot plot encodes value by position, not area.


``` r
ggplot(df_amounts, aes(x = value, y = category)) +
  geom_point(size = 3) + 
  theme_classic()
```

![](05_01_week_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;

Interpretation:
- easier endpoint comparison
- less ink

---

# Amounts: ordering matters

When categories are unordered, default order can hide comparisons.


``` r
df_amounts_ord &lt;- df_amounts %&gt;%
  arrange(value) %&gt;%
  mutate(category = factor(category, levels = category))

ggplot(df_amounts_ord, aes(x = category, y = value)) +
  geom_col() + 
  theme_classic()
```

![](05_01_week_files/figure-html/unnamed-chunk-5-1.png)&lt;!-- --&gt;

---

# Distributions: histogram (baseline)

Use when:
- you need to understand shape (skew, multimodality)


``` r
ggplot(df_dist, aes(x = outcome)) +
  geom_histogram(bins = 30) + 
  theme_classic()
```

![](05_01_week_files/figure-html/unnamed-chunk-6-1.png)&lt;!-- --&gt;

---

# Histograms and bin size choices

A histogram requires a choice:
- how wide each bin should be
- how many bins to use

These choices affect:
- perceived smoothness
- apparent modes
- where “peaks” appear

---

# Default histogram (ggplot decides)


``` r
ggplot(df_dist, aes(x = outcome)) +
  geom_histogram() +
  theme_classic()
```

```
## `stat_bin()` using `bins = 30`. Pick better value `binwidth`.
```

![](05_01_week_files/figure-html/unnamed-chunk-7-1.png)&lt;!-- --&gt;

Interpretation:

* ggplot chooses a bin width automatically
* This is reasonable as a **first look**
* You should not treat it as a final answer

---

# Explicit bin choice (you decide)


``` r
ggplot(df_dist, aes(x = outcome)) + 
  geom_histogram(bins = 30) +
  theme_classic()
```

![](05_01_week_files/figure-html/unnamed-chunk-8-1.png)&lt;!-- --&gt;

Interpretation:

* The data are unchanged
* Only the aggregation has changed
* Apparent “shape” can look different

---

# Why this matters

* Too few bins:

  * hides structure
  * oversmooths the distribution
* Too many bins:

  * creates noise
  * suggests false irregularity

**Rule of thumb:**
Use the default to explore, then justify your bin choice.

---

# Distributions: compare groups (boxplot)

Use when:
- you care about differences in typical values and spread


``` r
ggplot(df_dist, aes(x = group, y = outcome)) +
  geom_boxplot() + 
  theme_classic()
```

![](05_01_week_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;

---

# Boxplots (what they show)

A boxplot summarizes a distribution using **five key quantities**:

- median (center line)
- 25th percentile (bottom of box)
- 75th percentile (top of box)
- lower whisker (typical minimum)
- upper whisker (typical maximum)

Points beyond the whiskers are shown as **potential outliers**.

---

# What boxplots are good for

- Comparing **distributions across groups**
- Seeing differences in:
  - central tendency
  - spread
  - asymmetry
- Compact summaries when you have many groups

---

# What boxplots hide

- Exact distribution shape
- Multimodality
- Individual observations (except outliers)

**Key idea:**  
Boxplots trade detail for comparability.

---

# Proportions: bars are usually clearer than pies

Bars make comparison easier than angles or areas.


``` r
ggplot(df_props, aes(x = segment, y = prop)) +
  geom_col()  + 
  theme_classic()
```

![](05_01_week_files/figure-html/unnamed-chunk-10-1.png)&lt;!-- --&gt;


---


# Proportions: pie chart (for critique)

Pie charts encode by angle/area, which is hard to compare precisely.


``` r
ggplot(df_props, aes(x = "", y = prop, fill = segment)) +
  geom_col(width = 1) +
  coord_polar(theta = "y") +
  labs(x = "", y = "") +
  theme(axis.text = element_blank(), axis.ticks = element_blank()) + 
  theme_classic()
```

![](05_01_week_files/figure-html/unnamed-chunk-11-1.png)&lt;!-- --&gt;

---

# Relationships: scatterplot

Use when:
- you want to see association + outliers + nonlinearity


``` r
ggplot(df_xy, aes(x = x, y = y)) +
  geom_point() + 
  theme_classic()
```

![](05_01_week_files/figure-html/unnamed-chunk-12-1.png)&lt;!-- --&gt;

---



# Data visualization critique 

- Take five minutes
  - What variables are mapped to what (x/y/color/size/etc.)?
  - Is it persuasive? 
  - What design choices did they make?
  - After doing this talk to your neighbor briefly and compare notes.

.center[
&lt;img src="homicides.png" style="width:65%;"&gt;
]

---

# Time: line plot (minimal)

Use when:
- x is time (ordered)
- you want to show evolution


``` r
ggplot(df_time, aes(x = t, y = y)) +
  geom_smooth(method = "lm") +
  geom_point() + 
  theme_classic()
```

```
## `geom_smooth()` using formula = 'y ~ x'
```

![](05_01_week_files/figure-html/unnamed-chunk-13-1.png)&lt;!-- --&gt;

---

# Uncertainty: points with error bars

Use when:
- you want to show an estimate and its range


``` r
ggplot(df_unc, aes(x = label, y = est)) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = lo, ymax = hi), width = 0.2) + 
  theme_classic()
```

![](05_01_week_files/figure-html/unnamed-chunk-14-1.png)&lt;!-- --&gt;


---


# The principle of proportional ink

A visualization should not exaggerate differences by accident.

Key idea:
- the visual “ink” used to represent a value should be proportional to that value

Most common violation:
- truncating a bar axis

---

# Proportional ink: misleading truncated bar axis

This makes differences look larger than they are.


``` r
ggplot(df_amounts, aes(x = category, y = value)) +
  geom_col() +
  coord_cartesian(ylim = c(30, 45)) + 
  theme_classic()
```

![](05_01_week_files/figure-html/unnamed-chunk-15-1.png)&lt;!-- --&gt;

---

# Proportional ink: correct baseline (bars start at zero)


``` r
ggplot(df_amounts, aes(x = category, y = value)) +
  geom_col() + 
  theme_classic()
```

![](05_01_week_files/figure-html/unnamed-chunk-16-1.png)&lt;!-- --&gt;

Interpretation:
- same data
- different implied magnitude

---

# When not to use bars

Bars are a bad choice when:

- the axis is logarithmic (length no longer proportional to value)
- you only need ranked comparison (dots can be cleaner)
- you have too many categories (labels become the bottleneck)

---


# Data visualization critique 

- Take five minutes
  - What variables are mapped to what (x/y/color/size/etc.)?
  - Is it persuasive? 
  - What design choices did they make?
  - After doing this talk to your neighbor briefly and compare notes.

.center[
&lt;img src="height_men.png" style="width:50%;"&gt;
]

---

# Pie charts and area distortions

Pie charts often violate proportional thinking because:

- we judge angles and areas poorly
- small differences are hard to detect

If magnitude matters:
- prefer bars or dots

---

# Proportions: waffle plot (contrast to pie)

A waffle plot shows proportions as **counts of equal tiles**.
It makes “how many” more concrete than angles.


``` r
library(waffle)
waffle_counts &lt;- setNames(
  round(df_props$prop * 100),
  df_props$segment)
waffle_counts[1] &lt;- waffle_counts[1] + (100 - sum(waffle_counts))
waffle::waffle(waffle_counts, rows = 10, size = 0.6) +
  theme_classic()
```

![](05_01_week_files/figure-html/unnamed-chunk-17-1.png)&lt;!-- --&gt;

---


# Tidy data: the prerequisite for plotting

To make ggplot work smoothly, your data should be “tidy”:

- each variable is a column
- each observation is a row
- each value is a cell

---

# Wide vs long (simple example)

Wide format (harder for many ggplot tasks):


``` r
df_wide &lt;- data.frame(
  id = c("A","B","C"),
  bp1 = c(100, 140, 120),
  bp2 = c(110, 115, 125)
)

df_wide
```

```
##   id bp1 bp2
## 1  A 100 110
## 2  B 140 115
## 3  C 120 125
```

---

# Pivot longer (make it tidy)


``` r
df_long &lt;- df_wide %&gt;%
  pivot_longer(
    cols = c(bp1, bp2),
    names_to = "measurement",
    values_to = "value"
  )

df_long
```

```
## # A tibble: 6 × 3
##   id    measurement value
##   &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;
## 1 A     bp1           100
## 2 A     bp2           110
## 3 B     bp1           140
## 4 B     bp2           115
## 5 C     bp1           120
## 6 C     bp2           125
```

---

# Plot after tidying (mapping becomes simple)


``` r
ggplot(df_long, aes(x = measurement, y = value, group = id)) +
  geom_point() +
  geom_line() + 
  theme_classic()
```

![](05_01_week_files/figure-html/unnamed-chunk-20-1.png)&lt;!-- --&gt;

Interpretation:
- the plot becomes easy because the data are structured for it

---

# Pivot wider (when you need one row per unit)

Sometimes you want one row per unit again.


``` r
df_wide_again &lt;- df_long %&gt;%
  pivot_wider(
    names_from = measurement,
    values_from = value
  )

df_wide_again
```

```
## # A tibble: 3 × 3
##   id      bp1   bp2
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 A       100   110
## 2 B       140   115
## 3 C       120   125
```

---

# A practical rule

If you feel like ggplot is “fighting you,” it usually means:

- your data are not tidy
- or you have not defined the question clearly

Fix the structure before you fix the plot.

---

# In-person data visualization example

We will pause here and look at a real visualization.

Focus on:

- what question it seems to answer
- whether the visual encoding is proportional
- whether the data structure is clear from the plot

---

# What success looks like

- You can identify the task:
  - amounts, distributions, proportions, relationships, time, uncertainty
- You can justify a plot choice for a question
- You can spot a proportional-ink violation
- You can tidy a simple dataset for plotting

---

# In-Class Activity


Find a visualization online.

With a neighbor:
- Identify the data variables
- Identify the visual mappings
- Decide what message the plot is making
- Suggest one concrete improvement

---

# What Comes Next

Next, you will:
- reshape (tidy) data for plotting
- choose a plot type based on the question
- practice avoiding proportional-ink mistakes

Focus on clarity, not complexity.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
  "highlightStyle": "github",
  "highlightLines": true,
  "countIncrementalSlides": false,
  "slideNumberFormat": ""
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
